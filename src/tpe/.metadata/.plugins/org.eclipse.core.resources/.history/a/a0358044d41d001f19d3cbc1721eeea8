package m;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BacktrackingAssignment {

    private List<Procesador> mejoresAsignaciones;
    private int mejorTiempo;

    public BacktrackingAssignment() {
        mejoresAsignaciones = new ArrayList();
        mejorTiempo = 120;
    }

    public List<Procesador> encontrarMejoresAsignaciones(List<Procesador> procesadores, List<Tarea> tareas, int limiteTareasCriticas, int limiteTiempoNoRefrigerado) {
        // Inicializa la llamada recursiva con asignaciones vacÃ­as y sin asignar tareas
        backtrack(new ArrayList<>(), procesadores, new ArrayList<>(tareas), limiteTareasCriticas, limiteTiempoNoRefrigerado);
        System.out.println("asignacion actual"+ mejoresAsignaciones);

        return mejoresAsignaciones;
    }

    private void backtrack(ArrayList<Procesador> asignacionActual, List<Procesador> procesadores, List<Tarea> tareasRestantes, int limiteTareasCriticas, int limiteTiempoNoRefrigerado) {
        // Verifica si se ha completado una asignaciÃ³n
        if (tareasRestantes.isEmpty()) {
            // Calcula el tiempo final de ejecuciÃ³n para la asignaciÃ³n actual
            int tiempoFinal = calcularTiempoFinal(asignacionActual);
            // Verifica si esta asignaciÃ³n es la mejor hasta ahora
            if (tiempoFinal < mejorTiempo) {
                mejoresAsignaciones.clear();
                mejoresAsignaciones.addAll(asignacionActual);
                mejorTiempo = tiempoFinal;
             	System.out.println("asignacion actual"+ mejoresAsignaciones);
             	System.out.println("el mejor tiempo es "+ mejorTiempo);
             	return;
            }
             else if (tiempoFinal == mejorTiempo) {
                mejoresAsignaciones.addAll(asignacionActual);
            	//System.out.println("asignacion actual"+ mejoresAsignaciones);

            }
            
            return;
        }

        // Selecciona una tarea para asignar
        Tarea tarea = tareasRestantes.get(0);

        // Prueba asignar la tarea a cada procesador disponible
        for (Procesador procesador : procesadores) {
            // Verifica restricciones antes de asignar
            if (verificarRestricciones(asignacionActual, procesador, tarea, limiteTareasCriticas, limiteTiempoNoRefrigerado)) {
                // Asigna la tarea al procesador actual
                asignarTarea(asignacionActual, procesador, tarea);

                // Elimina la tarea asignada de la lista de tareas restantes
                tareasRestantes.remove(tarea);

                // Llama recursivamente con la nueva asignaciÃ³n y las tareas restantes actualizadas
                backtrack(asignacionActual, procesadores, tareasRestantes, limiteTareasCriticas, limiteTiempoNoRefrigerado);

                // Deshace la asignaciÃ³n para probar con otro procesador
                desasignarTarea(asignacionActual, procesador, tarea);

                // Agrega nuevamente la tarea a la lista de tareas restantes para la siguiente iteraciÃ³n
            tareasRestantes.add(0, tarea);

            }
        }
    }



    private boolean verificarRestricciones(ArrayList<Procesador> asignacion, Procesador procesador, Tarea tarea, int limiteTareasCriticas, int limiteTiempoNoRefrigerado) {
        // Verifica restricciÃ³n de mÃ¡ximo de tareas crÃ­ticas por procesador
    	int totalTareasCriticas = 0;
    	for(Procesador p : asignacion){
    		if(p.equals(procesador)){
    			for(Tarea t : p.getTareas())
	    			if (tarea.isCritica() &&  t.isCritica()) {
	    				 totalTareasCriticas++;
	    			}    			
    		}
    		
    		if(totalTareasCriticas >= limiteTareasCriticas){
    			return false;    			
    		}
    	}

        // Verifica restricciÃ³n de tiempo para procesadores no refrigerados
    	int tiempoAsignado = 0;
    	
    	if(!procesador.refrigerado()){
    		for(Procesador p : asignacion){
    			if(p.equals(procesador)){
    				for(Tarea t : p.getTareas()){
    					tiempoAsignado += t.getTiempo();
    				}
    				
    				tiempoAsignado += tarea.getTiempo();
    				if(tiempoAsignado >= limiteTiempoNoRefrigerado){
    					return false;
    				}
    			}
    		}    		
    	}

        return true;
    }

    private void asignarTarea(ArrayList<Procesador> asignacion, Procesador procesador, Tarea tarea) {
			    	 Procesador procesadorEnAsignacion = asignacion.stream()
			                 .filter(p -> p.equals(procesador))
			                 .findFirst()
			                 .orElse(null);
			if (procesadorEnAsignacion != null) {
			// Si el procesador ya está en la asignación, clonémoslo antes de agregar la tarea
			Procesador procesadorClonado = new Procesador(procesadorEnAsignacion.getId(), 
			                      procesadorEnAsignacion.getCodigo(), 
			                      procesadorEnAsignacion.refrigerado(), 
			                      procesadorEnAsignacion.getAnio());
			procesadorClonado.getTareas().addAll(procesadorEnAsignacion.getTareas());
			procesadorClonado.getTareas().add(tarea);
			asignacion.remove(procesadorEnAsignacion); // Eliminamos el procesador original de la asignación
			asignacion.add(procesadorClonado); // Agregamos el procesador clonado con la nueva tarea
			} else {
			// Si el procesador no está en la asignación, simplemente agreguemos el nuevo procesador con la tarea
			Procesador nuevoProcesador = new Procesador(procesador.getId(), 
			                    procesador.getCodigo(), 
			                    procesador.refrigerado(), 
			                    procesador.getAnio());
			nuevoProcesador.getTareas().add(tarea);
			asignacion.add(nuevoProcesador);
			}

    }

    private void desasignarTarea(List<Procesador> asignacion, Procesador procesador, Tarea tarea) {
    	Procesador procesadorEnAsignacion = asignacion.stream()
			                .filter(p -> p.equals(procesador))
			                .findFirst()
			                .orElse(null);
					if (procesadorEnAsignacion != null) {
							// Si el procesador está en la asignación, clonémoslo antes de eliminar la tarea
							Procesador procesadorClonado = new Procesador(procesadorEnAsignacion.getId(), 
							                     procesadorEnAsignacion.getCodigo(), 
							                     procesadorEnAsignacion.refrigerado(), 
							                     procesadorEnAsignacion.getAnio());
							procesadorClonado.getTareas().addAll(procesadorEnAsignacion.getTareas());
							procesadorClonado.getTareas().remove(tarea);
							asignacion.remove(procesadorEnAsignacion); // Eliminamos el procesador original de la asignación
									if (!procesadorClonado.getTareas().isEmpty()) {
											// Si el procesador clonado aún tiene tareas, lo volvemos a agregar a la asignación
											asignacion.add(procesadorClonado);
					}
			}
    }

    private int calcularTiempoFinal(ArrayList<Procesador> asignacion) {
        int tiempoFinal = 0;
        for(Procesador a : asignacion){
        	ArrayList <Tarea> tareas = a.getTareas(); 
	        	for (Tarea t : tareas) {
	        		tiempoFinal = Math.max(tiempoFinal, tareas.stream().mapToInt(Tarea::getTiempo).sum());
	        	}
        }
        return tiempoFinal;
    }
}
