package m;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BacktrackingAssignment {

    private ArrayList<Procesador> mejoresAsignaciones;
    private int mejorTiempo;

    public BacktrackingAssignment() {
        mejoresAsignaciones = new ArrayList();
        mejorTiempo = 120;
    }

    public ArrayList<Procesador> encontrarMejoresAsignaciones(List<Procesador> procesadores, List<Tarea> tareas, int limiteTareasCriticas, int limiteTiempoNoRefrigerado) {
        // Inicializa la llamada recursiva con asignaciones vacías y sin asignar tareas
        backtrack(new ArrayList<>(), procesadores, new ArrayList<>(tareas), limiteTareasCriticas, limiteTiempoNoRefrigerado);
        System.out.println("asignacion actual"+ mejoresAsignaciones);

        return mejoresAsignaciones;
    }

    private void backtrack(ArrayList<Procesador> asignacionActual, List<Procesador> procesadores, List<Tarea> tareasRestantes, int limiteTareasCriticas, int limiteTiempoNoRefrigerado) {
        // Verifica si se ha completado una asignación
        if (tareasRestantes.isEmpty()) {
            // Calcula el tiempo final de ejecución para la asignación actual
            int tiempoFinal = calcularTiempoFinal(asignacionActual);
            // Verifica si esta asignación es la mejor hasta ahora
            if (tiempoFinal < mejorTiempo) {
                mejoresAsignaciones.clear();
                mejoresAsignaciones.addAll(asignacionActual);
                mejorTiempo = tiempoFinal;
             	System.out.println("asignacion actual"+ mejoresAsignaciones);
             	System.out.println("el mejor tiempo es "+ mejorTiempo);
             	return;
            }
             else if (tiempoFinal == mejorTiempo) {
                mejoresAsignaciones.addAll(asignacionActual);
            	//System.out.println("asignacion actual"+ mejoresAsignaciones);

            }
            
            return;
        }

        // Selecciona una tarea para asignar
        Tarea tarea = tareasRestantes.get(0);

        // Prueba asignar la tarea a cada procesador disponible
        for (Procesador procesador : procesadores) {
            // Verifica restricciones antes de asignar
            if (verificarRestricciones(asignacionActual, procesador, tarea, limiteTareasCriticas, limiteTiempoNoRefrigerado)) {
                // Asigna la tarea al procesador actual
                asignarTarea(asignacionActual, procesador, tarea);

                // Elimina la tarea asignada de la lista de tareas restantes
                tareasRestantes.remove(tarea);

                // Llama recursivamente con la nueva asignación y las tareas restantes actualizadas
                backtrack(asignacionActual, procesadores, tareasRestantes, limiteTareasCriticas, limiteTiempoNoRefrigerado);

                // Deshace la asignación para probar con otro procesador
                desasignarTarea(asignacionActual, procesador, tarea);

                // Agrega nuevamente la tarea a la lista de tareas restantes para la siguiente iteración
            tareasRestantes.add(0, tarea);

            }
        }
    }



    private boolean verificarRestricciones(ArrayList<Procesador> asignacion, Procesador procesador, Tarea tarea, int limiteTareasCriticas, int limiteTiempoNoRefrigerado) {
        // Verifica restricción de máximo de tareas críticas por procesador
    	int totalTareasCriticas = 0;
    	for(Procesador p : asignacion){
    		if(p.equals(procesador)){
    			for(Tarea t : p.getTareas())
	    			if (tarea.isCritica() &&  t.isCritica()) {
	    				 totalTareasCriticas++;
	    			}    			
    		}
    		
    		if(totalTareasCriticas >= limiteTareasCriticas){
    			return false;    			
    		}
    	}

        // Verifica restricción de tiempo para procesadores no refrigerados
    	int tiempoAsignado = 0;
    	
    	if(!procesador.refrigerado()){
    		for(Procesador p : asignacion){
    			if(p.equals(procesador)){
    				for(Tarea t : p.getTareas()){
    					tiempoAsignado += t.getTiempo();
    				}
    				
    				tiempoAsignado += tarea.getTiempo();
    				if(tiempoAsignado >= limiteTiempoNoRefrigerado){
    					return false;
    				}
    			}
    		}    		
    	}

        return true;
    }

    private void asignarTarea(ArrayList<Procesador> asignacion, Procesador procesador, Tarea tarea) {
    	asignacion.add(procesador);
    	procesador.addTarea(tarea);

    }

    private void desasignarTarea(Map<Procesador, List<Tarea>> asignacion, Procesador procesador, Tarea tarea) {
        if (asignacion.containsKey(procesador)) {
            asignacion.get(procesador).remove(tarea);
            if (asignacion.get(procesador).isEmpty()) {
                asignacion.remove(procesador);
            }
        }
    }

    private int calcularTiempoFinal(ArrayList<Procesador> asignacion) {
        int tiempoFinal = 0;
        for(Procesador a : asignacion){
        	ArrayList <Tarea> tareas = a.getTareas(); 
	        	for (Tarea t : tareas) {
	        		tiempoFinal = Math.max(tiempoFinal, tareas.stream().mapToInt(Tarea::getTiempo).sum());
	        	}
        }
        return tiempoFinal;
    }
}
